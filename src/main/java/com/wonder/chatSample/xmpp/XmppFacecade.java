package com.wonder.chatSample.xmpp;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.google.gson.JsonArray;import com.wonder.chatSample.model.User;import com.wonder.chatSample.service.UserService;import com.wonder.chatSample.webSocket.model.WebsocketMessage;import com.wonder.chatSample.webSocket.utility.WebSocketTextMessageHelper;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.jivesoftware.smack.SmackException;import org.jivesoftware.smack.XMPPException;import org.jivesoftware.smack.packet.Presence;import org.jivesoftware.smack.roster.RosterEntry;import org.jivesoftware.smack.tcp.XMPPTCPConnection;import org.springframework.stereotype.Component;import javax.websocket.EncodeException;import javax.websocket.Session;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Optional;import java.util.Set;import static com.wonder.chatSample.webSocket.model.MessageType.*;@Slf4j@Component@RequiredArgsConstructorpublic class XmppFacecade {    private final UserService userService;    private final WebSocketTextMessageHelper webSocketTextMessageHelper;    private final XmppConfig xmppConfig;    private static final Map<Session, XMPPTCPConnection> CONNECTIONS = new HashMap<>();    public void startSession(Session session, String username, String password) throws EncodeException, IOException, SmackException, XMPPException, InterruptedException {       /*  TODO: Save user session to avoid having to login again when the websocket connection is closed              1. Generate token              2. Save username and token in Redis              3. Return token to client and store it in a cookie or local storage              4. When starting a websocket session check if the token is still valid and bypass XMPP authentication        */        Optional<XMPPTCPConnection> connection = xmppConfig.createXmppConnection(username, password);        if (connection.isEmpty()) {            log.info("XMPP connection was not established. Closing websocket session...");            webSocketTextMessageHelper.send(session, WebsocketMessage.builder().messageType(ERROR).build());            session.close();        }        Optional<User> user = Optional.ofNullable(userService.getOne(new QueryWrapper<User>().eq("name", username)));        try {            if (user.isEmpty()) {                log.info("Creating new account.");                xmppConfig.createXmppAccount(connection.get(), username, password);                log.info("Account created.");            }            log.info("Login into account.");            xmppConfig.login(connection.get());        } catch (XMPPGenericException e) {            handleXMPPGenericException(session, connection.get(), e);        }        Optional<User> user2 = Optional.ofNullable(userService.getOne(new QueryWrapper<User>().eq("name", username)));        if (null != user2.get().getName() && !(password.equals(user2.get().getPwd()))) {            log.warn("Invalid password for user {}.", username);            webSocketTextMessageHelper.send(session, WebsocketMessage.builder().messageType(FORBIDDEN).build());        }        CONNECTIONS.put(session, connection.get());        log.info("Session was stored.");        xmppConfig.addIncomingMessageListener(connection.get(), session);        webSocketTextMessageHelper.send(session, WebsocketMessage.builder().to(username).messageType(JOIN_SUCCESS).build());    }    public void sendMessage(WebsocketMessage websocketMessage, Session session) throws EncodeException, IOException {        XMPPTCPConnection connection = CONNECTIONS.get(session);        if (connection != null) {            switch (websocketMessage.getMessageType()) {                case NEW_MESSAGE -> {                    try {                        xmppConfig.sendMsg(connection, websocketMessage.getContent(), websocketMessage.getTo());                        //TODO:  save to histry                    } catch (XMPPGenericException | SmackException.NotConnectedException | InterruptedException e) {                        handleXMPPGenericException(session, connection, e);                    }                }                case ADD_CONTACT -> {                    try {                        xmppConfig.addContact(connection, websocketMessage.getTo());                    } catch (XMPPGenericException e) {                        handleXMPPGenericException(session, connection, e);                    }                }                case UNSUBSCRIBE -> {                    try {                        xmppConfig.remove(connection, websocketMessage.getTo());                    } catch (XMPPGenericException e) {                        handleXMPPGenericException(session, connection, e);                    }                }                case GET_CONTACTS -> {                    Set<RosterEntry> contacts = Set.of();                    try {                        contacts = xmppConfig.contactList(connection);                    } catch (XMPPGenericException e) {                        handleXMPPGenericException(session, connection, e);                    }                    JsonArray jsonArray = new JsonArray();                    for (RosterEntry entry : contacts) {                        jsonArray.add(entry.getName());                    }                    WebsocketMessage respons = WebsocketMessage.builder().content(jsonArray.toString()).messageType(GET_CONTACTS).build();                }            }        }    }    public void disconnect(Session session) throws EncodeException, IOException {        XMPPTCPConnection connection = CONNECTIONS.get(session);        if(connection != null) {            try{                xmppConfig.sendStanza(connection, Presence.Type.unavailable);            }catch (XMPPGenericException e){                log.error("XMPP error.", e);                webSocketTextMessageHelper.send(session, WebsocketMessage.builder().messageType(ERROR).build());            }            xmppConfig.disconnect(connection);            CONNECTIONS.remove(session);        }    }    private void handleXMPPGenericException(Session session, XMPPTCPConnection connection, Exception e) throws EncodeException, IOException {        log.error("XMPP error. Disconnecting and removing session...", e);        xmppConfig.disconnect(connection);        webSocketTextMessageHelper.send(session, WebsocketMessage.builder().messageType(ERROR).build());        CONNECTIONS.remove(session);    }}