package com.wonder.chatSample.xmpp;import com.wonder.chatSample.model.User;import com.wonder.chatSample.service.UserService;import javax.websocket.EncodeException;import javax.websocket.Session;import com.wonder.chatSample.webSocket.model.MessageType;import com.wonder.chatSample.webSocket.model.WebsocketMessage;import lombok.extern.slf4j.Slf4j;import org.jivesoftware.smack.*;import org.jivesoftware.smack.chat2.Chat;import org.jivesoftware.smack.chat2.ChatManager;import org.jivesoftware.smack.packet.Message;import org.jivesoftware.smack.packet.Presence;import org.jivesoftware.smack.packet.PresenceBuilder;import org.jivesoftware.smack.roster.Roster;import org.jivesoftware.smack.roster.RosterEntry;import org.jivesoftware.smack.tcp.XMPPTCPConnection;import org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration;import org.jivesoftware.smackx.iqregister.AccountManager;import org.jivesoftware.smackx.offline.OfflineMessageManager;import org.jxmpp.jid.BareJid;import org.jxmpp.jid.EntityBareJid;import org.jxmpp.jid.EntityFullJid;import org.jxmpp.jid.impl.JidCreate;import org.jxmpp.jid.parts.Localpart;import org.jxmpp.stringprep.XmppStringprepException;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.io.IOException;import java.util.List;import java.util.Optional;import java.util.Set;import static com.wonder.chatSample.webSocket.model.MessageType.PRESENCE;@Slf4j@Configurationpublic class XmppConfig {    // Define your XMPP domain    String domain = "Ari";    EntityBareJid entityBareJid;    public XmppConfig(UserService userService, XMPPMessageTransmitter xmppMessageTransmitter) {        this.userService = userService;        this.xmppMessageTransmitter = xmppMessageTransmitter;    }    private final UserService userService;    private final XMPPMessageTransmitter xmppMessageTransmitter;    // Remove userName and password parameters from the bean method    @Bean    public XMPPTCPConnection xmppConnection() {        // Return null or an invalid connection initially, since we can't connect without credentials.        return null;    }    public Optional<XMPPTCPConnection> createXmppConnection(String userName, String password) {        XMPPTCPConnection connection;        try {            // XMPP connection configuration            entityBareJid = JidCreate.entityBareFrom(userName + "@" + domain);            XMPPTCPConnectionConfiguration config = XMPPTCPConnectionConfiguration.builder()                    .setUsernameAndPassword(entityBareJid.getLocalpart(), password)                    .setXmppDomain("Ari")                    .setHost("127.0.0.1")                    .setPort(5222)                    .setSecurityMode(ConnectionConfiguration.SecurityMode.disabled) // Security disabled for development                    .setResource(entityBareJid.getResourceOrEmpty())                    .setSendPresence(true)                    .build();            connection = new XMPPTCPConnection(config);            connection.connect();            return Optional.of(connection);        } catch (InterruptedException | XMPPException | SmackException | IOException e) {            log.info("Could not connect to XMPP server.", e);            return Optional.empty();        }    }    public void createXmppAccount(XMPPTCPConnection connection, String username, String password) throws XmppStringprepException, XMPPException.XMPPErrorException, SmackException.NotConnectedException, SmackException.NoResponseException, InterruptedException {        // Account creation        AccountManager accountManager = AccountManager.getInstance(connection);        accountManager.sensitiveOperationOverInsecureConnection(true);        accountManager.createAccount(Localpart.from(username), password);        // Store user details (assumed to be saved via a service layer)        User user = new User().setName(username).setPwd(password);        userService.save(user);    }    public void login(XMPPTCPConnection connection) {        try {            connection.login();// Attempts to log in            // Create a presence stanza indicating the user is available            Presence presence = PresenceBuilder.buildPresence()                    .ofType(Presence.Type.available) // Set presence type to available                    .setStatus("Online") // Optionally set a custom status message                    .build(); // Build the presence object            // Send the presence stanza            connection.sendStanza(presence);            // Now, subscribe to another user's presence            subscribeToPresence(connection, entityBareJid);        } catch (XMPPException | SmackException | IOException | InterruptedException e) {            log.error("Login to XMPP server with user {} failed.", connection.getUser(), e);            EntityFullJid user = connection.getUser();            throw new XMPPGenericException(user == null ? "unknown" : user.toString(), e);        }        log.info("User '{}' logged in.", connection.getUser());    }    private void subscribeToPresence(XMPPTCPConnection connection, EntityBareJid userToSubscribe) {        try {            // Get the roster for the current connection            Roster roster = Roster.getInstanceFor(connection);            // Set the default subscription mode to manual            roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);            // Create a new entry for the user you want to subscribe to            roster.createEntry(userToSubscribe, null, null); // null can be replaced with groups if needed            // Send a subscription request            Presence presence = PresenceBuilder.buildPresence()                    .ofType(Presence.Type.subscribe) // Set the presence type to subscribe\                    .from(entityBareJid)                    .build(); // Build the presence object            connection.sendStanza(presence);            log.info("Subscription request sent to {}", userToSubscribe);        } catch (Exception e) {            log.error("Unable to subscribe to user {}: ", userToSubscribe, e);        }    }    public void addIncomingMessageListener(XMPPTCPConnection connection, Session webSocketSession) {        ChatManager chatManager = ChatManager.getInstanceFor(connection);        chatManager.addIncomingListener((from, message, chat) -> {                    try {                        xmppMessageTransmitter.sendResponse(message, webSocketSession);                    } catch (EncodeException | IOException e) {                        throw new RuntimeException(e);                    }                } // Send received message via WebSocket        );        log.info("Incoming message listener for user '{}' added.", connection.getUser());    }    /*    * Method Overview:        Chat Manager: The method uses the ChatManager to start a chat with the recipient, identified by the to parameter.        Message Sending: The method sends a message using the Chat.send() method.        Logging: After the message is successfully sent, it logs the action with details about the sender and recipient.    * */    public void sendMsg(XMPPTCPConnection connection, String message, String to) throws XmppStringprepException, SmackException.NotConnectedException, InterruptedException {        ChatManager chatManager = ChatManager.getInstanceFor(connection);        Chat chat = chatManager.chatWith(JidCreate.entityBareFrom(to + "@" + domain));// Start a chat with the recipient        Roster roster = Roster.getInstanceFor(connection);        RosterEntry entry = roster.getEntry(JidCreate.entityBareFrom(to + "@" + domain));        // Ensure the roster is loaded        if (!roster.isLoaded()) {            try {                roster.reloadAndWait();            } catch (SmackException.NotConnectedException | SmackException.NotLoggedInException | InterruptedException e) {                log.error("Error loading roster: ", e);            }        }        Presence presence = roster.getPresence(JidCreate.entityBareFrom(to + "@" + domain));        System.out.println("---------------------------------------------------------------presence.status: "+presence.getType());//        if (presence.isAvailable()) {            chat.send(message); // Send the message//        }else{//            // store the message in Queuse//        }        log.info("Message sent to user '{}' from user '{}'.", to, connection.getUser());    }    public void disconnect(AbstractXMPPConnection connection) {        if (connection != null && connection.isConnected()) {            connection.disconnect(); // Disconnect the XMPP connection        }    }    /*     * Method Overview:     * Stanza Type: The method takes an XMPP Presence.Type (e.g., available, unavailable, etc.) as input and creates a Presence stanza using the builder pattern.     * Sending the Stanza: It then sends the presence stanza using the connection.sendStanza() method.     * Error Handling: The method logs and throws an exception if there is an error during the process (such as the connection not being established).     * */    public void sendStanza(XMPPTCPConnection connection, Presence.Type type) {        Presence presence = PresenceBuilder.buildPresence().ofType(type)//                .setStatus("I am away")  // Set custom status                .build();        try {            connection.sendStanza(presence);            log.info("Status {} sent for user '{}'.", type, connection.getUser());        } catch (SmackException.NotConnectedException | InterruptedException e) {            log.error("XMPP error.", e);            throw new XMPPGenericException(connection.getUser().toString(), e);        }    }    public void addContact(XMPPTCPConnection connection, String to) {        Roster roster = Roster.getInstanceFor(connection);        if (!roster.isLoaded()) {            try {                roster.reloadAndWait();            } catch (SmackException.NotConnectedException | SmackException.NotLoggedInException |                     InterruptedException e) {                throw new XMPPGenericException(connection.getUser().toString(), e);            }        }        try {            BareJid contact = JidCreate.bareFrom(to);            roster.createItemAndRequestSubscription(contact, to, null);            log.info("Contact '{}' added to user '{}'.", to, connection.getUser());        } catch (XmppStringprepException | SmackException.NotLoggedInException | SmackException.NoResponseException |                 XMPPException.XMPPErrorException | SmackException.NotConnectedException | InterruptedException e) {            log.error("XMPP error. Disconnecting and removing session...", e);            throw new XMPPGenericException(connection.getUser().toString(), e);        }    }    public void remove(XMPPTCPConnection connection, String to) {        Roster roster = Roster.getInstanceFor(connection);        if (!roster.isLoaded()) {            try {                roster.reloadAndWait();            } catch (SmackException.NotConnectedException | SmackException.NotLoggedInException |                     InterruptedException e) {                throw new XMPPGenericException(connection.getUser().toString(), e);            }        }        try {            BareJid contact = JidCreate.bareFrom(to);            roster.removeEntry(roster.getEntry(contact));            log.info("User '{}' removed contact '{}'.", connection.getUser(), to);        } catch (XmppStringprepException | XMPPException.XMPPErrorException                 | SmackException.NotConnectedException | SmackException.NoResponseException                 | SmackException.NotLoggedInException | InterruptedException e) {            log.error("XMPP error. Disconnecting and removing session...", e);            throw new XMPPGenericException(connection.getUser().toString(), e);        }    }    public Set<RosterEntry> contactList(XMPPTCPConnection connection) {        Roster roster = Roster.getInstanceFor(connection);        if (!roster.isLoaded()) {            try {                roster.reloadAndWait();            } catch (SmackException.NotConnectedException | SmackException.NotLoggedInException |                     InterruptedException e) {                throw new XMPPGenericException(connection.getUser().toString(), e);            }        }        return roster.getEntries();    }    // to handle offline message    public void offlineMessage(XMPPTCPConnection xmpptcpConnection, Session session) {        OfflineMessageManager offlineMessageManager = OfflineMessageManager.getInstanceFor(xmpptcpConnection);        try {            if (offlineMessageManager.supportsFlexibleRetrieval()) {                // get offline message Count                int offlineMsgCount = offlineMessageManager.getMessageCount();                log.info("User '{}' has {} offline messages.", xmpptcpConnection.getUser(), offlineMsgCount);                if (offlineMsgCount > 0) {                    List<Message> offlineMessage = offlineMessageManager.getMessages();                    offlineMessage.forEach(                            message -> {                                try {                                    xmppMessageTransmitter.sendResponse(message, session);                                } catch (EncodeException | IOException e) {                                    throw new RuntimeException(e);                                }                            }                    );                    offlineMessageManager.deleteMessages();                    log.info("Processed offline messages for user '{}'.", xmpptcpConnection.getUser());                }            } else {                log.warn("Server does not support flexible offline message retrieval.");            }        } catch (Exception e) {            log.warn("Server does not support flexible offline message retrieval: {} ", e.getMessage());        }    }    public void addPresenceListener(XMPPTCPConnection connection, Session webSocketSession) {        connection.addAsyncStanzaListener(                stanza -> {                    if (stanza instanceof Presence presence) {                        String from = presence.getFrom().toString();                        String to = presence.getTo().toString();                        // Check presence availability and status                        String presenceStatus = presence.isAvailable() ? "online" : "offline";                        String statusMessage = presence.getStatus(); // Custom status message (e.g., "Away", "Busy")                        int priority = presence.getPriority();       // Priority for multi-client scenarios                        System.out.println(" presence "+ statusMessage+ "priority: " + priority);                        // Send presence update to WebSocket                        xmppMessageTransmitter.sendPresence(                                webSocketSession,                                WebsocketMessage.builder()                                        .from(from)                                        .to(to)                                        .messageType(MessageType.PRESENCE)                                        .content(presenceStatus + " (" + statusMessage + ") with priority " + priority)                                        .build()                        );                        log.info("Received presence from '{}': {}, Status: {}, Priority: {}",                                from, presenceStatus, statusMessage, priority);                    }                },                stanza -> stanza instanceof Presence // Predicate to filter only presence stanzas        );    }    public void sendPresence(XMPPTCPConnection connection, Presence.Type presenceType, Presence.Mode mode, String statusMessage, int priority)            throws SmackException.NotConnectedException, InterruptedException {        Presence presence = PresenceBuilder.buildPresence()                .ofType(presenceType)      // Set type (available, unavailable, etc.)                .setMode(mode)             // Set mode (away, dnd, etc.)                .setStatus(statusMessage)   // Set custom status message (e.g., "Working")                .setPriority(priority)      // Set priority (for multi-client presence)                .build();        // Send the presence stanza        connection.sendStanza(presence);        log.info("Sent presence: type={}, mode={}, status='{}', priority={}",                presenceType, mode, statusMessage, priority);    }}