package com.wonder.chatSample.xmpp;import com.wonder.chatSample.model.User;import com.wonder.chatSample.service.UserService;import javax.websocket.EncodeException;import javax.websocket.Session;import lombok.extern.slf4j.Slf4j;import org.jivesoftware.smack.AbstractXMPPConnection;import org.jivesoftware.smack.ConnectionConfiguration;import org.jivesoftware.smack.SmackException;import org.jivesoftware.smack.XMPPException;import org.jivesoftware.smack.chat2.Chat;import org.jivesoftware.smack.chat2.ChatManager;import org.jivesoftware.smack.packet.Presence;import org.jivesoftware.smack.packet.PresenceBuilder;import org.jivesoftware.smack.roster.Roster;import org.jivesoftware.smack.roster.RosterEntry;import org.jivesoftware.smack.tcp.XMPPTCPConnection;import org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration;import org.jivesoftware.smackx.iqregister.AccountManager;import org.jxmpp.jid.BareJid;import org.jxmpp.jid.EntityBareJid;import org.jxmpp.jid.EntityFullJid;import org.jxmpp.jid.impl.JidCreate;import org.jxmpp.jid.parts.Localpart;import org.jxmpp.stringprep.XmppStringprepException;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.io.IOException;import java.util.Optional;import java.util.Set;@Slf4j@Configurationpublic class XmppConfig {    // Define your XMPP domain    String domain = "Ari";    public XmppConfig(UserService userService, XMPPMessageTransmitter xmppMessageTransmitter) {        this.userService = userService;        this.xmppMessageTransmitter = xmppMessageTransmitter;    }    private final UserService userService;    private final XMPPMessageTransmitter xmppMessageTransmitter;    // Remove userName and password parameters from the bean method    @Bean    public XMPPTCPConnection xmppConnection() {        // Return null or an invalid connection initially, since we can't connect without credentials.        return null;    }    public Optional<XMPPTCPConnection> createXmppConnection(String userName, String password) {        XMPPTCPConnection connection;        try {            // XMPP connection configuration            EntityBareJid entityBareJid = JidCreate.entityBareFrom(userName+"@"+domain);            XMPPTCPConnectionConfiguration config = XMPPTCPConnectionConfiguration.builder()                    .setUsernameAndPassword(entityBareJid.getLocalpart(), password)                    .setXmppDomain("Ari")                    .setHost("127.0.0.1")                    .setPort(5222)                    .setSecurityMode(ConnectionConfiguration.SecurityMode.disabled) // Security disabled for development                    .setResource(entityBareJid.getResourceOrEmpty())                    .setSendPresence(true)                    .build();            connection = new XMPPTCPConnection(config);            connection.connect();            return Optional.of(connection);        }catch (InterruptedException | XMPPException | SmackException | IOException  e){            log.info("Could not connect to XMPP server.", e);            return Optional.empty();        }    }    public void createXmppAccount(XMPPTCPConnection connection, String username, String password) throws XmppStringprepException, XMPPException.XMPPErrorException, SmackException.NotConnectedException, SmackException.NoResponseException, InterruptedException {        // Account creation        AccountManager accountManager = AccountManager.getInstance(connection);        accountManager.sensitiveOperationOverInsecureConnection(true);        accountManager.createAccount(Localpart.from(username), password);        // Store user details (assumed to be saved via a service layer)        User user = new User().setName(username).setPwd(password);        userService.save(user);    }    public void login(XMPPTCPConnection connection) {        try {            connection.login();// Attempts to log in        } catch (XMPPException | SmackException | IOException | InterruptedException e) {            log.error("Login to XMPP server with user {} failed.", connection.getUser(), e);            EntityFullJid user = connection.getUser();            throw new XMPPGenericException(user == null ? "unknown" : user.toString(), e);        }        log.info("User '{}' logged in.", connection.getUser());    }    public void addIncomingMessageListener(XMPPTCPConnection connection, Session webSocketSession) {        ChatManager chatManager = ChatManager.getInstanceFor(connection);        chatManager.addIncomingListener((from, message, chat) -> {                    try {                        xmppMessageTransmitter.sendResponse(message, webSocketSession);                    } catch (EncodeException | IOException e) {                        throw new RuntimeException(e);                    }                } // Send received message via WebSocket        );        log.info("Incoming message listener for user '{}' added.", connection.getUser());    }    /*    * Method Overview:        Chat Manager: The method uses the ChatManager to start a chat with the recipient, identified by the to parameter.        Message Sending: The method sends a message using the Chat.send() method.        Logging: After the message is successfully sent, it logs the action with details about the sender and recipient.    * */    public void sendMsg(XMPPTCPConnection connection, String message, String to) throws XmppStringprepException, SmackException.NotConnectedException, InterruptedException {        ChatManager chatManager = ChatManager.getInstanceFor(connection);        Chat chat = chatManager.chatWith(JidCreate.entityBareFrom(to+"@"+domain));// Start a chat with the recipient        chat.send(message); // Send the message        log.info("Message sent to user '{}' from user '{}'.", to, connection.getUser());    }    public void disconnect(AbstractXMPPConnection connection) {        if (connection != null && connection.isConnected()) {            connection.disconnect(); // Disconnect the XMPP connection        }    }    /*     * Method Overview:     * Stanza Type: The method takes an XMPP Presence.Type (e.g., available, unavailable, etc.) as input and creates a Presence stanza using the builder pattern.     * Sending the Stanza: It then sends the presence stanza using the connection.sendStanza() method.     * Error Handling: The method logs and throws an exception if there is an error during the process (such as the connection not being established).     * */    public void sendStanza(XMPPTCPConnection connection, Presence.Type type) {        Presence presence = PresenceBuilder.buildPresence().ofType(type)//                .setStatus("I am away")  // Set custom status                .build();        try {            connection.sendStanza(presence);            log.info("Status {} sent for user '{}'.", type, connection.getUser());        } catch (SmackException.NotConnectedException | InterruptedException e) {            log.error("XMPP error.", e);            throw new XMPPGenericException(connection.getUser().toString(), e);        }    }    public void addContact(XMPPTCPConnection connection, String to) {        Roster roster = Roster.getInstanceFor(connection);        if (!roster.isLoaded()) {            try {                roster.reloadAndWait();            } catch (SmackException.NotConnectedException | SmackException.NotLoggedInException |                     InterruptedException e) {                throw new XMPPGenericException(connection.getUser().toString(), e);            }        }        try {            BareJid contact = JidCreate.bareFrom(to);            roster.createItemAndRequestSubscription(contact, to, null);            log.info("Contact '{}' added to user '{}'.", to, connection.getUser());        } catch (XmppStringprepException | SmackException.NotLoggedInException | SmackException.NoResponseException |                 XMPPException.XMPPErrorException | SmackException.NotConnectedException | InterruptedException e) {            log.error("XMPP error. Disconnecting and removing session...", e);            throw new XMPPGenericException(connection.getUser().toString(), e);        }    }    public void remove(XMPPTCPConnection connection, String to) {        Roster roster = Roster.getInstanceFor(connection);        if (!roster.isLoaded()) {            try {                roster.reloadAndWait();            } catch (SmackException.NotConnectedException | SmackException.NotLoggedInException |                     InterruptedException e) {                throw new XMPPGenericException(connection.getUser().toString(), e);            }        }        try {            BareJid contact = JidCreate.bareFrom(to);            roster.removeEntry(roster.getEntry(contact));            log.info("User '{}' removed contact '{}'.", connection.getUser(), to);        } catch (XmppStringprepException | XMPPException.XMPPErrorException                 | SmackException.NotConnectedException | SmackException.NoResponseException                 | SmackException.NotLoggedInException | InterruptedException e) {            log.error("XMPP error. Disconnecting and removing session...", e);            throw new XMPPGenericException(connection.getUser().toString(), e);        }    }    public Set<RosterEntry> contactList(XMPPTCPConnection connection) {        Roster roster = Roster.getInstanceFor(connection);        if (!roster.isLoaded()) {            try {                roster.reloadAndWait();            } catch (SmackException.NotConnectedException | SmackException.NotLoggedInException |                     InterruptedException e) {                throw new XMPPGenericException(connection.getUser().toString(), e);            }        }        return roster.getEntries();    }}